#--------------------------------------------
# FUNCTION: bash.utils.quit()
# DESCRIPTION:
# Print EXIT line to console and exit
# Parameters: 
#   $1, string - console message
#--------------------------------------------
function bash.utils.quit() {
  local ln="${1:?}"
  printf "%s\n" "[EXIT]: ${ln}"

  exit 1
}

#--------------------------------------------
# FUNCTION: bash.utils.is_root()
# DESCRIPTION:
# Check if uid is root
# Parameters: 
#   none
#--------------------------------------------
function bash.utils.is_root() {
  [[ $UID -eq 0 ]] \
  || bash.utils.quit 'You must be root to execute this script'
}

#--------------------------------------------
# FUNCTION: bash.utils.sudo_user()
# DESCRIPTION:
# Get the sudo user's name
# Parameters: 
#   none
#--------------------------------------------
function bash.utils.sudo_user() {
  if [[ $SUDO_USER ]]; then 
    this_user="${SUDO_USER}"
  else 
    this_user=$(logname)
  fi
}

#--------------------------------------------
# FUNCTION: bash.utils.consoleLog()
# DESCRIPTION:
# Print INFO line to console with newline
# Parameters: 
#   $1, string - console message
#--------------------------------------------
function bash.utils.consoleLog() {
  local ln="${1:?}"
  printf "%s\n" "[INFO]: ${ln}"
}

#--------------------------------------------
# FUNCTION: bash.utils.consoleLogDate()
# DESCRIPTION:
# Print INFO line to console with date and newline
# Parameters: 
#   $1, string - Date w/ console message
#--------------------------------------------
function bash.utils.consoleLogDate() {
  local ln="${1:?}"
  printf "%s %s\n" "[INFO][$(date +'%a %Y-%m-%d %H:%M:%S %z')]:" "${ln}"
}

#--------------------------------------------
# FUNCTION: bash.utils.writeln()
# DESCRIPTION:
# Print line to console without newline
# Parameters: 
#   $1, string - console message
#--------------------------------------------
function bash.utils.writeln() {
  local ln="${1:?}"
  printf "%s" "${ln}"
}

#--------------------------------------------
# FUNCTION: bash.utils.is_empty()
# DESCRIPTION:
# Return true if value empty or unset, else false
# Parameters: 
#   $1, string - variable to check
#--------------------------------------------
function bash.utils.is_empty() {
  # Return true if value empty or unset
  if [[ -z $1 ]]; then
      # return 0, is empty
      return 0
  fi
  # return 1, not empty
  return 1
}

#--------------------------------------------
# FUNCTION: bash.utils.is_integer()
# DESCRIPTION:
# Return true if integer, else false
# Parameters: 
#   $1, string - variable to check
#--------------------------------------------
function bash.utils.is_integer() {
  # Return true if integer
  if [[ -n $1 ]]; then
      printf "%d" $1 > /dev/null 2>&1
      return $?
  fi
  # return 1, not a number
  return 1
}

#--------------------------------------------
# FUNCTION: bash.utils.to_lower()
# DESCRIPTION:
# Convert string to lower case
# Parameters: 
#   $1, string - convert to lower case
#--------------------------------------------
function bash.utils.to_lower() {
  local ln="${1?}"

  # Check value is not empty, for speed.
  if ( bash.utils.is_empty ${ln} ); then
    # return 0, is empty, but we don't care
    return 0
  fi

  # Convert to lower case
  echo -e "${ln}" | tr '[:upper:]' '[:lower:]' | xargs 2>/dev/null
  # return 0, we don't care
  return 0
}

#--------------------------------------------
# FUNCTION: bash.utils.to_upper()
# DESCRIPTION:
# Convert string to upper case
# Parameters: 
#   $1, string - convert to upper case
#--------------------------------------------
function bash.utils.to_upper() {
  local ln="${1?}"

  # Check value is not empty, for speed.
  if ( bash.utils.is_empty ${ln} ); then
    # return 0, is empty, but we don't care
    return 0
  fi

  # Convert to upper case
  echo -e "${ln}" | tr '[:lower:]' '[:upper:]' | xargs 2>/dev/null
  # return 0, we don't care
  return 0
}

#--------------------------------------------
# FUNCTION: bash.utils.find_os_kernel()
# DESCRIPTION:
# Use 'uname -s' to find Darwin or Linux
# Parameters: 
#   none
#--------------------------------------------
function bash.utils.find_os_kernel() {
  # Detect Linux or Darwin
  printf "%s" "$(uname -s)" >/dev/null 2>&1
}

#--------------------------------------------
# FUNCTION: bash.utils.find_os_family()
# DESCRIPTION:
# Use facter to fine osfamily
# Parameters: 
#   none
#--------------------------------------------
function bash.utils.find_os_family() {
  # Detect Linux or Darwin
  facter osfamily >/dev/null 2>&1
}

#--------------------------------------------
# FUNCTION: bash.utils.find_os()
# DESCRIPTION:
# Use facter to get operatingsystem
# Parameters: 
#   none
#--------------------------------------------
function bash.utils.find_os() {
  # Detect Linux or Darwin
  facter operatingsystem >/dev/null 2>&1
}

#--------------------------------------------
# FUNCTION: bash.utils.common_packages()
# DESCRIPTION:
# Enusre some common packages are installed
# Parameters: 
#   none
#--------------------------------------------
function bash.utils.common_packages() {

  if ( bash.utils.find_os_kernel == "Linux"); then
    if ( bash.utils.find_os_family == "redhat"); then
      if ( bash.utils.find_os == "fedora"); then
        bash.utils.consoleLogDate "Enusre some common packages are installed."
        dnf install -y vim vim-common git screen tmux
      fi
    fi
    
    if ( bash.utils.find_os_family == "debian"); then
      if ( bash.utils.find_os == "fedora"); then
        bash.utils.consoleLogDate "Enusre some common packages are installed."
        apt-get install -y vim vim-common git screen tmux
      fi
    fi
    
  fi

  if ( bash.utils.find_os_kernel == "Darwin"); then
    if ( bash.utils.find_os == "darwin"); then
      bash.utils.consoleLogDate "Enusre some common packages are installed."
      brew install -y vim vim-common git screen tmux
    fi
    
  fi
  
  bash.utils.consoleLog "Common $OSTYPE packages are installed."
  
  return
}

#--------------------------------------------
# FUNCTION: bash.utils.check_exit_status()
# DESCRIPTION:
# Check and handle exit status errors
# check_exit_status $?
# check_exit_status $? [SKIP/IGNORE]
# Parameters: 
#   $1, $?  - ($?)  Expands to the exit status
#   $2, string - Ignore check if exit status is 1
#--------------------------------------------
function bash.utils.check_exit_status() {
    local exit_status=$1
    local test_skip=$2

    if [ "${exit_status}" -ne 0 ]; then # test failed
        if [ -n "${test_skip}" ]; then
          # write test skip to files
          printf "%s" '[CHECK EXIT STATUS]: Skipped [ OK ]'
          return 
        else
          # ERROR: Caught a bad exit status.
          # printf "%s" '[CHECK EXIT STATUS]: Status [ Failed ]'
          # Could do error_cleanup here
          exit $?
        fi
    fi
    # printf "%s" '[CHECK EXIT STATUS]: Status [ OK ]'
}

#--------------------------------------------
# FUNCTION: bash.utils.find_git_repo()
# DESCRIPTION:
# Check for and update existing local git repo 
# or clone source/remote
# Parameters: 
#   $1, string - source git repo
#   $2, string - local git repo
#--------------------------------------------
function bash.utils.find_git_repo() {
v_srcrepo=$(printf "%s" "$1")
v_localrepo=$(printf "%s" "$2")

  # Check for an empty string
  if ( ! bash.utils.is_empty ${v_srcrepo} ) && ( ! bash.utils.is_empty ${v_localrepo} ); then
   # Detect repo
      if [ ! -d "${v_localrepo}" ]; then
      git clone ${v_srcrepo} ${v_localrepo}
    else
      cd "${v_localrepo}"
      git pull ${v_srcrepo}
    fi
  else
    printf "%s\n" "[Info]: Please specify a source and local repo."
  fi
}

# Export functions to other bash sub-shells
# typeset -fx bash.utils.check_exit_status
